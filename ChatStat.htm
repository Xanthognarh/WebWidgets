<!DOCTYPE html>
<!--
Config via URL-Parameters:
- `channel`: Name of Twitch Channel(s) you want to listen (also works for Shared Chat). Separate Channels with comma.
- `kernel`: Kernel of the KDE Plot. Choose one of [Normal, Epanechnikov, Box, Biweight, Triweight, Triangular]  [default: normal]
- `bg`: r,g,b,a value  for the background-color (0-255) and alpha (0-1) [default: white-transparent (230,230,255,0.8)]
- `axiscolor`: r,g,b,a value  for the axis-color (0-255) and alpha (0-1) [default: black (0,0,0,1)]
- `linecolor`: r,g,b,a value  for the line-color (0-255) and alpha (0-1) [default: black (0,0,0,1)]
- `fillcolor`: r,g,b,a value  for the fill-color (0-255) and alpha (0-1) [default: blue-transparent (50,50,255,0.5)]
- `hidden`: 0: Not hidden or 1: hidden when loading the page. Visibility can be changed by chat commands. [default=0]
- `debug`: Allow multiple votes per user and commands can be used by everyone
use them like: ChatStat.htm?channel=Testchannel&debug=1
-->
<html>
	<header>
		<meta charset="UTF-8">
		<title>Xanthopoll</title>		
	</header>
	<script src="Scripts/tmi.min.js"></script>
	<style>
		body{
			margin:0;
		}
		#plot{
			width: 100%;
			height: 100%;
			position: absolute;
		}
		#canvas{
			width: 100%;
			height: 100%;
		}

	</style>
	<body>
		<div id="plot">
			<canvas id="canvas"></canvas>
		</div>
	</body>
	<script charset="utf-8">
		StartNewVoteCommand="!newvote";
		ResetCommand="!resetvote";//Alias for StartNewVoteCommand
		HideVoteCommand="!hidevote";
		ShowVoteCommand="!showvote";
		ResetBlocklistCommand="!voteagain";
		StopVoteCommand="!stopvote";
		StartVoteCommand="!continuevote";
		
		TestCommand="!testdata";
		
		
		extraMods=[]; //only lower-case usernames (like in the url): extraMods=["name1","name2"];
	
		siteURL=new URL(window.location);
		TwitchChannel=siteURL.searchParams.get("channel").toLowerCase().split(",");
		kernel=siteURL.searchParams.get("kernel");
		if (kernel==null){kernel="normal";}
		bg=siteURL.searchParams.get("bg");
		if (bg==null){bg="230,230,255,0.8"}
		document.getElementById("canvas").style.backgroundColor="rgba("+bg+")";
		axcolor=siteURL.searchParams.get("axiscolor");
		if (axcolor==null){axcolor="0,0,0,1"}
		linecolor=siteURL.searchParams.get("linecolor");
		if (linecolor==null){linecolor="0,0,0,1"}
		fillcolor=siteURL.searchParams.get("fillcolor");
		if (fillcolor==null){fillcolor="50,50,255,0.5"}
		hidden=siteURL.searchParams.get("hidden");
		if (hidden*1==1){document.getElementById("plot").style.visibility="hidden"}
		
		debug=siteURL.searchParams.get("debug");
		if (debug!=null){
			debug=true;
		}else{
			debug=false;
		}

		
		
		/*
			Kernel
		*/
		function kernelNormal(x,μ=0,σ=1){
			return Math.exp(-1*(x-μ)**2/(2*σ**2))/(sqrt2PI*σ);
		}
		function kernelEpanechnikov(x){
			if (Math.abs(x)<1){
				return 0.75*(1-x**2);
			}else{
				return 0;
			}
		}
		function kernelBox(x){
			if (Math.abs(x)<1){
				return 0.5;
			}else{
				return 0;
			}
		}
		function kernelBiweight(x){
			if (Math.abs(x)<1){
				return 0.9375*(1-x**2)**2;
			}else{
				return 0;
			}
		}
		function kernelTriweight(x){
			if (Math.abs(x)<1){
				return 1.09375*(1-x**2)**3;
			}else{
				return 0;
			}
		}
		function kernelTriangular(x){
			if (Math.abs(x)<1){
				return (1-Math.abs(x));
			}else{
				return 0;
			}
		}
		
		/*
			Program
		*/
		
		votes=[];
		Userlist=[];
		allowvoting=true;
		const sqrt2PI=Math.sqrt(2*Math.PI);
		function generateData(n=10,modes=2,maxvalue=100,r=2){
			if (n<1 || modes<1){return false;}
			for (let i=0;i<n;i++){
				newvote(Number(Math.round(Math.random()*maxvalue/modes + Math.round((modes-1)*Math.random())*maxvalue/modes +"e"+r)+"e-"+r));
			}
		}
		
		function newvote(vote){
			//Insert vote to sorted votes
			let min = 0;
			let max = votes.length;
			let index = Math.floor(max*0.5);
			while (max > min) {
				if (vote < votes[index]) {
					max = index;
				} else {
					min = index + 1;
				}
				index = Math.floor((min + max)*0.5);
			}
			votes.splice(index, 0, vote);

			console.log(votes);
			update();
		}
		function update(h=null,percent=100,kernel="Normal"){
			const resolution=document.getElementById("canvas").clientWidth/1;
			if (percent>100 || percent<0){percent=100;}
			percent=100-percent;
			const skip=Math.floor(votes.length*percent*0.005);
			let min=votes.at(skip);
			let max=votes.at(-skip-1);
			console.log("Real min="+min+" max="+max);
			min=min-(max-min)*0.01;
			max=max+(max-min)*0.01
			const stepsize=(max-min)/resolution;
			if (h==null || h<=0){				
				let mean=0;
				for (i=skip;i<votes.length-skip;i++){
					mean+=votes.at(i);
				}
				mean=mean/(votes.length-2*skip);
				console.log("mean="+mean);
				let value=0;
				for (i=skip;i<votes.length-skip;i++){
					value+=(votes.at(i)-mean)**2;
				}
				const σ=Math.sqrt(value/(votes.length-2*skip));
				let IQR;
				//votes.at(index starts with 1)
				if (0.25*votes.length==Math.round(0.25*votes.length)){
					IQR=0.5*(votes.at(votes.length*0.75)+votes.at(votes.length*0.75 +1)) - 0.5*(votes.at(votes.length*0.25)+votes.at(votes.length*0.25 +1));
				}else{
					IQR=Math.floor(votes.at(votes.length*0.75+1)) - Math.floor(votes.at(votes.length*0.25+1));
				}
				h=1.06*Math.min(σ,IQR/1.34)*(votes.length-2*skip)**(-0.2);
				console.log("h="+h+" (calculated)");
				if (h>0.05*(max-min)){h=Math.min(4,(max-min)*0.02);console.log("h="+h+" (limited)");}
				h=1/h;
			}else{
				console.log("h="+h+" (fixed)");
				h=1/h;
			}
			
			KDE=[];
			X=[];
			ymax=0;
			switch(kernel.toLowerCase()){
				case "normal":
					kernel=kernelNormal;
					break;
				case "epanechnikov":
					kernel=kernelEpanechnikov;
					break;
				case "box":
					kernel=kernelBox;
					break;
				case "biweight":
					kernel=kernelBiweight;
					break;
				case "triweight":
					kernel=kernelTriweight;
					break;
				case "triangular":
					kernel=kernelTriangular;
					break;
				default:
					kernel=kernelNormal;
			}
			for (x=min;x<max;x+=stepsize){
				X.push(x);
				value=0;
				for (i=0;i<votes.length;i++){
					value+=kernel((x-votes[i])*h);
				}
				value=Math.max(0,value*h/votes.length);
				KDE.push(value);
				if (value>ymax){ymax=value;}
			}
			plot(X,KDE,min,max,ymax);
		}
		
		function plot(X,Y,min,max,ymax){
			console.log(arguments);
			const minSciExp=6;//Lowest |Exponent| to use scientific notation
			const SciExp=Math.min(minSciExp, Math.max(Math.abs(min.toExponential(2).split("e")[1]), Math.abs(max.toExponential(2).split("e")[1])))
			const c=document.getElementById("canvas");
			const ctx=c.getContext("2d");
			const mx=c.clientWidth;
			const my=c.clientHeight;
			c.width=mx;
			c.height=my;
			ctx.font = "48px serif";
			let metrics = ctx.measureText("0123456789e");
			const fontHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
			metrics = ctx.measureText("0."+"8".repeat(SciExp));
			const p=Math.min(mx,my)*0.01;
			const TickWidth=metrics.width+2*p;
			ctx.clearRect(0,0,mx,my);
			
			
			//Axes
			//ctx.fillText("0123456789e",0,my-1*p);
			ctx.strokeStyle="rgba("+axcolor+")";
			ctx.fillStyle="rgba("+axcolor+")";
			ctx.fillRect(0,my-fontHeight-2*p-0.5*fontHeight,mx,0.5*p);
			
			let n=Math.floor(mx/TickWidth)-1;
			[z,e]=(max-min).toExponential(2).split("e");
			ea=Math.abs(e*1);
			let tickstep=max-min;
			let tickstart=min;
			let tickround=1;
			let tickcount=0;
			if (z[0]*20+z[2]*2+Math.ceil(z[3]*0.1)<=n){
				//x.05, x.05, x.05,...
				tickstep=Number("0.05e"+e);
				tickround=2;
				tickstart=Math.floor(min*20)*0.05;
				tickcount=z[0]*20+z[2]*2+Math.ceil(z[3]*0.1)+1;
			}else if (z[0]*10+z[2]*1<=n){
				//x.1, x.2, x.3,...
				tickstep=Number("0.1e"+e);
				tickround=1;
				tickstart=Math.floor(min*10)*0.1;
				tickcount=z[0]*10+z[2]*1+1;
			}else if (z[0]*5+Math.ceil(z[2]*0.5)<=n){
				//x.0, x.2, x.4, ...
				tickstep=Number("0.2e"+e);
				tickround=1;
				tickstart=Math.floor(min*5)*0.2;
				tickcount=z[0]*5+Math.ceil(z[2]*0.5)+1;
			}else if (z[0]*2+Math.ceil(z[2]*0.1)<=n){
				//x.0, x.5
				tickstep=Number("0.5e"+e);
				tickround=1;
				tickstart=Math.floor(min*2)*0.5;
				tickcount=z[0]*2+Math.ceil(z[2]*0.1)+1;
			}else if (z[0]*1<=n){
				//1, 2, 3, ...
				tickstep=Number("1e"+e);
				tickround=0;
				tickstart=Math.floor(min);
				tickcount=z[0]*1+1
			}else {
				tickstep=(max-min)/n;
				tickround=2;
				tickcount=n;
			}
			
			i=1;
			//First and last Tick is skipped
			for(pos=tickstart+tickstep;pos<=max;pos+=tickstep){
				tick=Number(pos.toExponential(tickround));
				ctx.fillRect((tick-min)*mx/(max-min)-0.1*p, my-fontHeight-2*p,0.2*p+0.5,-0.5*fontHeight);
				textwidth=ctx.measureText(tick).width;
				ctx.fillText(tick,(tick-min)*mx/(max-min)-0.5*textwidth,my-1*p);
				i++;
			}
			
			//Plot XY
			posxaxis=my-fontHeight-2*p-0.5*fontHeight;
			yscale=(posxaxis-1.5*fontHeight-2*p)/ymax;
			ctx.strokeStyle="rgba("+linecolor+")";
			ctx.fillStyle="rgba("+fillcolor+")";
			ctx.beginPath();
			ctx.moveTo(0,posxaxis)
			
			for (i=0;i<X.length;i++){
				ctx.lineTo(i,posxaxis-yscale*Y[i]);
			}
			ctx.lineTo(mx,posxaxis);
			ctx.closePath();
			ctx.stroke();
			ctx.fill();
			
			//Find local maxima
			ctx.strokeStyle="rgba("+axcolor+")";
			ctx.fillStyle="rgba("+axcolor+")";
			let maxY=[];
			let maxX=[];
			for (i=1;i<X.length-1;i++){
				if (Y[i-1]<Y[i] && Y[i]>=Y[i+1]){
					maxY.push(Y[i]);
					maxX.push(X[i]);
					ctx.fillRect((X[i]-min)*mx/(max-min)-0.1*p,posxaxis-yscale*Y[i]+0.25*fontHeight,0.1*p,-0.5*fontHeight);
					
				}
			}
			
			//Remove local maxima to close for text
			const minDistanceMaxima=(TickWidth-2*p)*(max-min)/mx;
			i=1;
			while (i<maxY.length-1){
				if (maxX[i]-maxX[i-1] < minDistanceMaxima && maxX[i+1]-maxX[i] < minDistanceMaxima){
					if (maxY[i]==Math.max(maxY[i-1],maxY[i],maxY[i+1])){
						//Use middle, if equal or greater
						maxX.splice(i+1,1);
						maxY.splice(i+1,1);
						maxX.splice(i-1,1);
						maxY.splice(i-1,1);
					}else if (maxY[i-1]==Math.max(maxY[i-1],maxY[i],maxY[i+1])){
						//Use left
						maxX.splice(i,2);
						maxY.splice(i,2);
					}else{
						//Use right
						maxX.splice(i-1,2);
						maxY.splice(i-1,2);
					}
					i--;
				}else if (maxX[i]-maxX[i-1] < minDistanceMaxima){
					if (maxY[i-1]>=maxY[i]){
						//use left
						maxX.splice(i,1);
						maxY.splice(i,1);
					}else{
						//use right
						maxX.splice(i-1,1);
						maxY.splice(i-1,1);
					}
				}else{
					i++;
				}
			}
			
			//Write the maxima
			const maxvalue=Math.max(...maxY);
			ctx.font = "36px serif";
			for (i=0;i<maxX.length;i++){
				value=maxX[i].toFixed(2);
				textwidth=ctx.measureText(value).width;
				if (maxY[i]==maxvalue){
					ctx.font="bold 36px serif";
				}else{
					ctx.font = "36px serif";
				}
				ctx.fillRect((maxX[i]-min)*mx/(max-min)-0.2*p,posxaxis-yscale*maxY[i]+0.25*fontHeight,0.4*p,-p-0.5*fontHeight);
				ctx.fillText(value,(maxX[i]-min)*mx/(max-min)-0.5*textwidth,posxaxis-yscale*maxY[i]-p-0.5*fontHeight)
			}
		}
		plot([0,1],[1,5],0,1,5);
		
		
		//a=setInterval(function(){generateData(1,4,1000,2)},100)
		//clearInterval(a)
		
		
		//Connect to Twitchchat:
		const client = new tmi.Client({
			options: { debug: false },
			channels: TwitchChannel
		});
		client.connect().catch(console.error);
		client.on('message', (channel, user, message, self) => {
		// "Alca: Hello, World!"
		let vote=message.replace(",",".").replace(/[€$]/g, "");
		if (allowvoting && !isNaN(vote)){
			//Message is a valid vote format
			if (!Userlist.includes(user['display-name']) || debug){
				newvote(vote*1);
				Userlist.push(user['display-name']);
			}
				
		}else{
			if (user.mod || extraMods.includes(user['display-name'].toLowerCase()) || TwitchChannel.includes("#"+user['display-name'].toLowerCase()) || debug){
				//Authorised Users (Twitch Mods, extraMods, Broadcaster or in case of debug-mode: everyone)
				switch (message.split(" ")[0]){
					case StartNewVoteCommand:
						if (message.split(" ")[1].toLowerCase()!="kde"){document.getElementById("plot").style.visibility="hidden"; break;}
						document.getElementById("plot").style.visibility="visible";
						//no break
					case ResetCommand:
						//Reset Votes
						votes=[];
						//Reset Userlist
						Userlist=[];
						update();
						break;
					case TestCommand:
						werte=message.split(" ");
						if (werte.length>1 && werte[1]!=""){n=werte[1]*1;}else{n=10;}
						if (werte.length>2 && werte[2]!=""){m=werte[2]*1;}else{m=2;}
						if (werte.length>3 && werte[3]!=""){x=werte[3]*1;}else{x=100;}
						if (werte.length>4 && werte[4]!=""){r=werte[4]*1;}else{r=2;}
						generateData(n,m,x,r);
						break;
					case HideVoteCommand:
						document.getElementById("plot").style.visibility="hidden";
						break;
					case ShowVoteCommand:
						document.getElementById("plot").style.visibility="visible";
						break;
					case StopVoteCommand:
						allowvoting=false;
						break;
					case StartVoteCommand:
						allowvoting=true;
						break;
					case ResetBlocklistCommand:
						Userlist=[];
						break;
				}
			}
			
		}
		//document.getElementById("Chatlog").innerHTML+=`<br><b>${user['display-name']}</b>: ${message}`;
		//console.log(`${user['display-name']}: ${message}`);
	});
	</script>
</html>